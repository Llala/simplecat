// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: translation_unit.sql

package db

import (
	"context"
	"database/sql"
)

const createTranslationUnit = `-- name: CreateTranslationUnit :one
INSERT INTO translation_unit (
  application_id,
  source_unit_id,
  text
) VALUES (
  $1, $2, NULL
)
RETURNING id, application_id, source_unit_id, text
`

type CreateTranslationUnitParams struct {
	ApplicationID int32 `json:"application_id"`
	SourceUnitID  int32 `json:"source_unit_id"`
}

func (q *Queries) CreateTranslationUnit(ctx context.Context, arg CreateTranslationUnitParams) (TranslationUnit, error) {
	row := q.db.QueryRowContext(ctx, createTranslationUnit, arg.ApplicationID, arg.SourceUnitID)
	var i TranslationUnit
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.SourceUnitID,
		&i.Text,
	)
	return i, err
}

const deleteTranslationUnit = `-- name: DeleteTranslationUnit :exec
DELETE FROM translation_unit
WHERE id = $1
`

func (q *Queries) DeleteTranslationUnit(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTranslationUnit, id)
	return err
}

const getTranslationUnit = `-- name: GetTranslationUnit :one
SELECT id, application_id, source_unit_id, text FROM translation_unit
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTranslationUnit(ctx context.Context, id int64) (TranslationUnit, error) {
	row := q.db.QueryRowContext(ctx, getTranslationUnit, id)
	var i TranslationUnit
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.SourceUnitID,
		&i.Text,
	)
	return i, err
}

const listTranslationUnits = `-- name: ListTranslationUnits :many
SELECT id, application_id, source_unit_id, text FROM translation_unit
WHERE application_id = $1
ORDER BY id
`

func (q *Queries) ListTranslationUnits(ctx context.Context, applicationID int32) ([]TranslationUnit, error) {
	rows, err := q.db.QueryContext(ctx, listTranslationUnits, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TranslationUnit{}
	for rows.Next() {
		var i TranslationUnit
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.SourceUnitID,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTranslationUnit = `-- name: UpdateTranslationUnit :one

UPDATE translation_unit
SET
  source_unit_id = COALESCE($1, source_unit_id),
  text = COALESCE($2, text)
WHERE
  id = $3
RETURNING id, application_id, source_unit_id, text
`

type UpdateTranslationUnitParams struct {
	SourceUnitID sql.NullInt32  `json:"source_unit_id"`
	Text         sql.NullString `json:"text"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateTranslationUnit(ctx context.Context, arg UpdateTranslationUnitParams) (TranslationUnit, error) {
	row := q.db.QueryRowContext(ctx, updateTranslationUnit, arg.SourceUnitID, arg.Text, arg.ID)
	var i TranslationUnit
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.SourceUnitID,
		&i.Text,
	)
	return i, err
}
